<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>MultiSnake — 1–4 players (local + P2P)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#071020cc; --accent:#27ae60; --muted:#9aa7b2;
    --tile-size:32px;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#061021 0%, #071124 100%); color:#e9f0f6; font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  .app{display:flex;flex-direction:column;height:100%;}
  header{padding:10px 12px; display:flex;gap:12px;align-items:center;}
  h1{font-size:18px;margin:0}
  #main{flex:1; display:flex; gap:10px; padding:10px; box-sizing:border-box; align-items:stretch;}
  .left{flex:1; min-width:240px; display:flex; flex-direction:column; gap:10px;}
  .canvas-wrap{background:var(--panel); padding:8px; border-radius:10px; display:flex; justify-content:center; align-items:center;}
  canvas{display:block; width:100%; height:auto; touch-action:none; border-radius:6px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .panel{background:var(--panel); padding:8px;border-radius:10px; min-width:220px;}
  button{background:transparent;border:1px solid #194; color:var(--accent); padding:6px 8px;border-radius:6px}
  input, textarea{width:100%; box-sizing:border-box; padding:6px;border-radius:6px;border:1px solid #113; background:transparent; color:inherit}
  .muted{color:var(--muted); font-size:13px}
  .dpad{width:140px;height:140px; border-radius:12px; background:rgba(0,0,0,0.15); display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap:6px; padding:6px; box-sizing:border-box;}
  .dpad button{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03); color:var(--muted); font-size:16px}
  .qr{width:100%;height:180px; background:#0a1014;border-radius:8px; display:flex;justify-content:center;align-items:center;color:var(--muted); font-size:12px}
  .footer{padding:8px;text-align:center;font-size:12px;color:var(--muted)}
  @media (max-width:700px){
    #main{flex-direction:column}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>MultiSnake (1–4 players) — mobile local & P2P</h1>
    <div style="margin-left:auto" class="muted">Touch controls / WebRTC P2P</div>
  </header>

  <div id="main">
    <div class="left">
      <div class="canvas-wrap panel">
        <canvas id="game" width="640" height="640" style="max-width:600px"></canvas>
      </div>

      <div style="display:flex;gap:8px">
        <div class="panel" style="flex:1">
          <div class="muted">Players</div>
          <label>Local players (1–4): <input id="localPlayers" type="number" min="1" max="4" value="1"></label>
          <div style="margin-top:8px">
            <button id="startLocal">Start Local Game</button>
            <button id="pauseBtn">Pause</button>
          </div>
          <div class="muted" style="margin-top:8px">Controls: on-screen D-pad (below) or swipe. Each player gets different color.</div>
        </div>

        <div class="panel" style="width:320px">
          <div class="muted">Network (P2P)</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="hostBtn">Host / Create Match</button>
            <button id="joinBtn">Join Match</button>
          </div>

          <div style="margin-top:8px">
            <textarea id="sigIn" placeholder="Paste offer or answer here" rows="4"></textarea>
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="doPaste">Process</button>
              <button id="copyOut">Copy Out</button>
            </div>
            <div id="sigOutWrap" style="margin-top:6px"><textarea id="sigOut" rows="3" readonly></textarea></div>
          </div>

          <div style="margin-top:8px" class="qr" id="qrWrap">QR / Offer will appear here when hosting.</div>
          <div class="muted" style="margin-top:6px">How-to: Host → press Host, share the OFFER (copy or QR). Players: press Join, paste OFFER and press Process to create ANSWER, share the ANSWER back to Host. Host pastes ANSWER and presses Process to finalize connection.</div>
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <div class="panel" style="flex:1">
          <div class="muted">Graphics</div>
          <label><input id="useRemote" type="checkbox" checked> Use web sprites (OpenGameArt)</label>
          <div class="muted" style="margin-top:6px">If images fail (CORS), the game will use simple colored tiles.</div>
        </div>

        <div class="panel" style="width:220px">
          <div class="muted">Speed & Grid</div>
          <label>Grid size: <input id="gridSize" type="number" value="20" min="8" max="40"></label>
          <label>Speed (ms): <input id="speed" type="number" value="120" min="40" max="400"></label>
        </div>
      </div>

    </div>

    <div style="width:320px;display:flex;flex-direction:column;gap:10px">
      <div class="panel">
        <div class="muted">On-screen D-pad</div>
        <div class="dpad" id="dpad">
          <div></div><button data-dir="up">▲</button><div></div>
          <button data-dir="left">◀</button><div></div><button data-dir="right">▶</button>
          <div></div><button data-dir="down">▼</button><div></div>
        </div>
        <div class="muted" style="margin-top:8px">Tap arrows to steer Player 1.</div>
      </div>

      <div class="panel" id="scoreboard">
        <div class="muted">Scoreboard</div>
        <div id="scores">No game yet</div>
      </div>

      <div class="panel">
        <div class="muted">Notes & Credits</div>
        <div style="font-size:13px">
          Sprites (when enabled) are loaded from OpenGameArt (permissive/CC0). If they cannot be loaded due to CORS, the game draws simple tiles. Network uses WebRTC data channels with manual signaling (copy/paste or QR). Works entirely inside this single HTML file.
        </div>
      </div>

    </div>
  </div>

  <div class="footer">Made for you — play on mobile. Network hints: open this page on all devices on the same LAN for the smoothest P2P connection.</div>
</div>

<!-- External tiny QR lib (inlined for single-file). Minimal QR generator (QRCode.js style) -->
<script>
/*! minimal QR encode - tiny version (draws QR from Google's chart API fallback if needed) */
function makeQR(text, size=160){
  // prefer using a data-URI via the Google Chart API (simple, no dependency).
  // Note: Google Chart API may be blocked; it's a fallback. We keep simple.
  const qurl = 'https://chart.googleapis.com/chart?cht=qr&chs='+size+'x'+size+'&chld=L|1&chl='+encodeURIComponent(text);
  const img = document.createElement('img');
  img.src = qurl;
  img.style.maxWidth='100%';
  img.style.maxHeight='100%';
  return img;
}
</script>

<script>
/* === MultiSnake logic (canvas + local players + P2P via WebRTC datachannel) ===
   Author: single-file implementation for mobile
   Network model: one "host" runs the authoritative game. Clients send only input frames.
   Host broadcasts authoritative state each tick.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d',{alpha:true});
let DPR = window.devicePixelRatio || 1;
function resizeCanvas(){
  // keep square canvas sized to viewport with DPR scaling
  const wrap = canvas.parentElement;
  const width = Math.min(wrap.clientWidth-10, 640);
  canvas.style.width = width + 'px';
  canvas.width = Math.floor(width*DPR);
  canvas.height = Math.floor(width*DPR);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const ui = {
  startLocal: document.getElementById('startLocal'),
  pauseBtn: document.getElementById('pauseBtn'),
  localPlayers: document.getElementById('localPlayers'),
  gridSize: document.getElementById('gridSize'),
  speed: document.getElementById('speed'),
  useRemote: document.getElementById('useRemote'),
  hostBtn: document.getElementById('hostBtn'),
  joinBtn: document.getElementById('joinBtn'),
  sigIn: document.getElementById('sigIn'),
  sigOut: document.getElementById('sigOut'),
  doPaste: document.getElementById('doPaste'),
  copyOut: document.getElementById('copyOut'),
  qrWrap: document.getElementById('qrWrap'),
  scores: document.getElementById('scores'),
};

let images = { apple:null, head:null, body:null, tile:null };
const remoteAssets = {
  // asset pages (OpenGameArt); we show cites above. We'll attempt to hotlink common direct filenames (may be blocked).
  apple: 'https://opengameart.org/sites/default/files/apple.png',
  // fallback snake sheet attempt - many authors serve files under OGA; these may 403 — code will handle fallback
  snakeSheet: 'https://opengameart.org/sites/default/files/snakesprites.png',
  grassTile: 'https://opengameart.org/sites/default/files/forest.png'
};

function loadImages(useRemote=true){
  const p = [];
  if(useRemote){
    p.push(loadImage(remoteAssets.apple).then(img=>images.apple=img).catch(()=>images.apple=null));
    p.push(loadImage(remoteAssets.snakeSheet).then(img=>images.head=img).catch(()=>images.head=null));
    p.push(loadImage(remoteAssets.grassTile).then(img=>images.tile=img).catch(()=>images.tile=null));
  } else {
    images={apple:null,head:null,body:null,tile:null};
  }
  return Promise.all(p);
}

function loadImage(url){
  return new Promise((res,rej)=>{
    const img=new Image();
    img.crossOrigin='anonymous';
    img.onload=()=>res(img);
    img.onerror=(e)=>rej(e);
    img.src=url;
  });
}

/* ===== Game state & logic ===== */
let G = {
  running:false,
  tickTimer:null,
  grid:20,
  cellSize:0,
  speed:120,
  players:[], // {id,color,dir,segments,alive,score,inputQueue}
  food:[],
  host:true, // if false => this client is a remote client
  localClientId:null,
  netPeers: {}, // peerId=>connection info
};

const COLORS = ['#27ae60','#e74c3c','#f1c40f','#3498db'];

function initGame(localPlayerCount=1){
  stopGame();
  G.grid = parseInt(ui.gridSize.value)||20;
  G.speed = parseInt(ui.speed.value)||120;
  // compute cell size from canvas size
  const minpx = Math.min(canvas.width, canvas.height);
  G.cellSize = Math.floor(minpx / G.grid);
  G.players = [];
  G.food = [];
  for(let i=0;i<localPlayerCount;i++){
    const p = {
      id: 'P'+(i+1),
      color: COLORS[i%COLORS.length],
      dir: 'right',
      segments: [],
      alive: true,
      score: 0,
      inputQueue: [],
      lastMoveTick:0
    };
    // spawn players in corners
    const spawn = spawnPosition(i, G.grid);
    p.segments = [spawn];
    G.players.push(p);
  }
  // spawn initial food
  for(let i=0;i<Math.max(1,localPlayerCount);i++) spawnFood();
  G.running = true;
  tick(); // immediate draw
  clearInterval(G.tickTimer);
  G.tickTimer = setInterval(tick, G.speed);
  updateScoreboard();
}

function spawnPosition(i, grid){
  const margin = 3;
  if(i==0) return {x:margin, y:margin};
  if(i==1) return {x:grid-1-margin, y:grid-1-margin};
  if(i==2) return {x:margin, y:grid-1-margin};
  return {x:grid-1-margin, y:margin};
}

function stopGame(){
  if(G.tickTimer) { clearInterval(G.tickTimer); G.tickTimer=null; }
  G.running=false;
}

function pauseToggle(){
  if(G.running){ stopGame(); ui.pauseBtn.textContent='Resume'; }
  else { G.running=true; ui.pauseBtn.textContent='Pause'; G.tickTimer = setInterval(tick, G.speed); }
}

/* handle input for local player (player 0) */
document.getElementById('dpad').addEventListener('pointerdown', e=>{
  const btn = e.target.closest('button[data-dir]');
  if(!btn) return;
  steerLocal(btn.dataset.dir);
});
function steerLocal(dir){
  if(!G.players[0] || !G.players[0].alive) return;
  // prevent reversing onto self
  const opposite = {up:'down',down:'up',left:'right',right:'left'};
  if(opposite[dir] === G.players[0].dir) return;
  G.players[0].dir = dir;
  // send network input if client
  if(!G.host && pc && dataChannel && dataChannel.readyState==='open'){
    sendNet({type:'input',dir:dir,playerId:G.localClientId||'P1'});
  }
}

/* swipe gestures */
let touchStart = null;
canvas.addEventListener('touchstart', e=>{ if(e.touches.length) touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY}; }, {passive:true});
canvas.addEventListener('touchend', e=>{
  if(!touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x, dy = t.clientY - touchStart.y;
  if(Math.abs(dx)>30 || Math.abs(dy)>30){
    if(Math.abs(dx)>Math.abs(dy)) steerLocal(dx>0 ? 'right':'left'); else steerLocal(dy>0 ? 'down':'up');
  }
  touchStart=null;
}, {passive:true});

/* main tick: if this client is host => advance authoritative state; else draws from last known remote state */
let lastState = null;
function tick(){
  if(G.host){
    // move snakes
    for(const p of G.players){
      if(!p.alive) continue;
      moveSnake(p);
    }
    // collisions & food
    resolveCollisions();
    // broadcast state to peers (and local clients if split)
    broadcastState();
    lastState = serializeState();
  } else {
    // not host: draw from lastState (updated when host's state arrives)
    if(!lastState) return render(); // nothing to render yet
    // local prediction: apply local queued inputs quickly (skipped to keep simplicity)
    // render lastState
    renderFromState(lastState);
  }
  render();
  updateScoreboard();
}

function moveSnake(p){
  const head = {...p.segments[0]};
  if(p.dir==='up') head.y--;
  if(p.dir==='down') head.y++;
  if(p.dir==='left') head.x--;
  if(p.dir==='right') head.x++;
  // wrap
  head.x = (head.x + G.grid) % G.grid;
  head.y = (head.y + G.grid) % G.grid;
  p.segments.unshift(head);
  // check eat food
  const ateIndex = G.food.findIndex(f=>f.x===head.x && f.y===head.y);
  if(ateIndex>=0){
    p.score += 1;
    G.food.splice(ateIndex,1);
    spawnFood();
  } else {
    p.segments.pop();
  }
}

function resolveCollisions(){
  // head-to-body collisions and head-to-head
  const posMap = new Map();
  for(const p of G.players){
    if(!p.alive) continue;
    const h = p.segments[0];
    const key = h.x + ',' + h.y;
    if(!posMap.has(key)) posMap.set(key, []);
    posMap.get(key).push({player:p,partIndex:0});
    // map bodies
    for(let i=1;i<p.segments.length;i++){
      const b = p.segments[i];
      const bk = b.x+','+b.y;
      if(!posMap.has(bk)) posMap.set(bk, []);
      posMap.get(bk).push({player:p,partIndex:i});
    }
  }
  // if a head collides with any other segment (including its own), kill head owner
  for(const [k, arr] of posMap.entries()){
    // count heads at location
    const heads = arr.filter(x => x.partIndex===0);
    if(heads.length){
      // if any head shares with other segments (>1 entry) then all heads that collide die
      if(arr.length>1){
        for(const h of heads) h.player.alive = false;
      }
    }
  }
}

function spawnFood(){
  // random free cell
  for(let tries=0; tries<200; tries++){
    const f = {x: Math.floor(Math.random()*G.grid), y: Math.floor(Math.random()*G.grid)};
    if(G.players.some(p=>p.segments.some(s=>s.x===f.x && s.y===f.y))) continue;
    if(G.food.some(ff=>ff.x===f.x && ff.y===f.y)) continue;
    G.food.push(f);
    return f;
  }
}

/* Draw & render */
function render(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.scale(DPR, DPR);
  const size = Math.floor(canvas.width/DPR);
  // draw background
  ctx.fillStyle = '#05202c';
  ctx.fillRect(0,0,size,size);
  // draw tiles grid faint
  const cs = Math.floor(size / G.grid);
  for(let x=0;x<G.grid;x++){
    for(let y=0;y<G.grid;y++){
      if(images.tile){
        // tile image: draw scaled to cs
        try{
          ctx.drawImage(images.tile, x*cs, y*cs, cs, cs);
        }catch(e){
          ctx.fillStyle = ( (x+y)%2 ? '#073' : '#065' );
          ctx.fillRect(x*cs, y*cs, cs, cs);
        }
      } else {
        ctx.fillStyle = ( (x+y)%2 ? '#063' : '#042' );
        ctx.fillRect(x*cs, y*cs, cs, cs);
      }
    }
  }
  // draw food
  for(const f of G.food){
    if(images.apple){
      try{
        ctx.drawImage(images.apple, f.x*cs, f.y*cs, cs, cs);
      }catch(e){
        ctx.fillStyle='#ff4d4d'; ctx.fillRect(f.x*cs+2, f.y*cs+2, cs-4, cs-4);
      }
    } else {
      ctx.fillStyle='#ff4d4d'; ctx.fillRect(f.x*cs+2, f.y*cs+2, cs-4, cs-4);
    }
  }
  // draw snakes
  for(const p of G.players){
    if(!p.alive) continue;
    ctx.fillStyle = p.color;
    for(let i=0;i<p.segments.length;i++){
      const s = p.segments[i];
      const inset = (i===0)?0:4;
      ctx.fillStyle = (i===0 ? shadeColor(p.color, -10) : p.color);
      ctx.fillRect(s.x*cs+inset, s.y*cs+inset, cs-(inset*2), cs-(inset*2));
      // optional head image
    }
  }
  ctx.restore();
}

/* Render from authoritative serialized state for clients */
function renderFromState(state){
  try{
    // shallow parse
    const st = state;
    // draw tiles, food, snakes similar to render but using st
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.scale(DPR,DPR);
    const size = Math.floor(canvas.width/DPR);
    ctx.fillStyle='#05202c'; ctx.fillRect(0,0,size,size);
    const cs = Math.floor(size / st.grid);
    for(let x=0;x<st.grid;x++){
      for(let y=0;y<st.grid;y++){
        ctx.fillStyle = ((x+y)%2) ? '#063' : '#042';
        ctx.fillRect(x*cs,y*cs,cs,cs);
      }
    }
    for(const f of st.food){
      ctx.fillStyle='#ff4d4d'; ctx.fillRect(f.x*cs+2,f.y*cs+2,cs-4,cs-4);
    }
    for(const p of st.players){
      if(!p.alive) continue;
      for(let i=0;i<p.segments.length;i++){
        const s = p.segments[i];
        ctx.fillStyle = p.color;
        ctx.fillRect(s.x*cs+2,s.y*cs+2,cs-4,cs-4);
      }
    }
    ctx.restore();
  }catch(e){ console.warn('renderFromState',e); }
}

/* simplistic scoreboard */
function updateScoreboard(){
  const s = G.players.map(p=>`${p.id}: ${p.score} ${p.alive? '':'(dead)'}`).join('<br>');
  ui.scores.innerHTML = s || 'No players';
}

/* state serialization */
function serializeState(){
  return {
    grid: G.grid,
    players: G.players.map(p=>({id:p.id, color:p.color, segments:p.segments, alive:p.alive, score:p.score})),
    food: G.food
  };
}

/* network: WebRTC datachannel manual signaling */
let pc = null;
let dataChannel = null;
let isHost = false;

function ensurePeer(){
  if(pc) return;
  pc = new RTCPeerConnection({
    iceServers:[{urls:['stun:stun.l.google.com:19302']}]
  });
  pc.onicecandidate = e=>{
    // when complete, put localDescription to sigOut
    if(e.candidate===null){
      const s = JSON.stringify(pc.localDescription);
      ui.sigOut.value = s;
      ui.copyOut.onclick = ()=>navigator.clipboard.writeText(s).catch(()=>{});
      // QR preview
      ui.qrWrap.innerHTML = '';
      ui.qrWrap.appendChild(makeQR(s,240));
    }
  };
  pc.ondatachannel = ev=>{
    dataChannel = ev.channel;
    setupDataChannel();
  };
}

function setupDataChannel(){
  if(!dataChannel) return;
  dataChannel.onopen = ()=>{ console.log('DC open'); };
  dataChannel.onmessage = e=>{
    try{
      const msg = JSON.parse(e.data);
      handleNetMessage(msg);
    }catch(err){ console.warn('bad msg',err); }
  };
  dataChannel.onclose = ()=>{ console.log('DC closed'); };
}

async function hostMatch(){
  isHost = true;
  ensurePeer();
  // create datachannel for clients to connect to host
  dataChannel = pc.createDataChannel('game');
  setupDataChannel();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // wait for ICE; onicecandidate will fill sigOut and QR
}

async function joinMatch(){
  isHost = false;
  ensurePeer();
  // create answer after remote offer is pasted
  // we'll rely on user to paste the offer to sigIn and press Process (ui.doPaste)
}

async function processSig(){
  // called by both host and join when they paste the remote SDP in sigIn
  const text = ui.sigIn.value.trim();
  if(!text) return alert('Paste offer/answer JSON into box first.');
  let desc;
  try{ desc = JSON.parse(text); }catch(e){ return alert('Invalid JSON'); }
  ensurePeer();
  if(desc.type === 'offer'){
    // this client is the JOINER
    await pc.setRemoteDescription(desc);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    // once ICE gathers, ui.sigOut will be filled by onicecandidate
  } else if(desc.type === 'answer'){
    // host receives answer from joiner
    await pc.setRemoteDescription(desc);
    // connection should establish
  } else {
    alert('Unknown description type');
  }
}

ui.doPaste.addEventListener('click', processSig);
ui.hostBtn.addEventListener('click', async ()=>{
  await loadImages(ui.useRemote.checked);
  await hostMatch();
  alert('Host mode: Offer will appear in the "Out" box (or QR). Share it with players.');
});
ui.joinBtn.addEventListener('click', async ()=>{
  await loadImages(ui.useRemote.checked);
  await joinMatch();
  alert('Join mode: paste OFFER into the input and press Process to generate an ANSWER to send back to host.');
});
ui.copyOut.addEventListener('click', ()=>navigator.clipboard.writeText(ui.sigOut.value).catch(()=>{}));

/* sending & receiving small JSON messages */
function sendNet(obj){
  try{
    if(dataChannel && dataChannel.readyState==='open') dataChannel.send(JSON.stringify(obj));
  }catch(e){ console.warn('sendNet',e); }
}

/* Host handles messages from clients: they send {type:'input',dir,playerId} */
function handleNetMessage(msg){
  if(isHost){
    if(msg.type==='input'){
      // find player by id and apply dir
      const p = G.players.find(x=>x.id===msg.playerId);
      if(p && p.alive && msg.dir){
        // avoid reversing
        const op = {up:'down',down:'up',left:'right',right:'left'};
        if(op[msg.dir] !== p.dir) p.dir = msg.dir;
      }
    }
  } else {
    // client: host may send state updates {type:'state', state:...}
    if(msg.type==='state'){
      lastState = msg.state;
      // update local render quickly
      renderFromState(lastState);
    }
  }
}

/* Broadcast authoritative state from host to clients */
function broadcastState(){
  if(!isHost || !dataChannel) return;
  const st = serializeState();
  sendNet({type:'state', state:st});
}

/* Basic peer connection setup: handle ICE candidates via signaling text as well.
   For simplicity (manual), we only exchange full SDP JSON blobs (offer/answer) via the textareas.
*/
ui.startLocal.addEventListener('click', async ()=>{
  const n = Math.min(4, Math.max(1, parseInt(ui.localPlayers.value)||1));
  await loadImages(ui.useRemote.checked);
  initGame(n);
  ui.pauseBtn.textContent='Pause';
});
ui.pauseBtn.addEventListener('click', pauseToggle);

/* utility */
function shadeColor(color, percent) {
  const f=color.slice(1),t=percent<0?0:255,p=percent<0?percent*-1:percent;
  const R=parseInt(f.substring(0,2),16),Gc=parseInt(f.substring(2,4),16),B=parseInt(f.substring(4,6),16);
  const newR=Math.round((t-R)*p/100)+R;
  const newG=Math.round((t-Gc)*p/100)+Gc;
  const newB=Math.round((t-B)*p/100)+B;
  return '#'+( (1<<24) + (newR<<16) + (newG<<8) + newB ).toString(16).slice(1);
}

/* If datachannel created on host side, we listen for open and then tag players (simple) */
function assignLocalIdsOnConnect(){
  // very simple: first connecting client becomes P2, next P3, next P4
  // would require tracking who joined; in this manual small demo we focus on single-host + single-join simple usage
}

/* Try to catch incoming messages from pc via datachannel open events */
setInterval(()=>{
  // if we're joiner and have a pc but no dataChannel, create one? No: joiner receives ondatachannel from host. so do nothing
},1000);

/* load images initially */
loadImages(true).then(()=>console.log('attempted remote image load')).catch(()=>{});

/* small safety: if page unloaded, close connections */
window.addEventListener('beforeunload', ()=>{ if(pc) pc.close(); });

</script>
